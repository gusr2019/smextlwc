(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[function(e,t,n){"use strict";(function(e){Object.defineProperty(t,"__esModule",{value:!0});const{isConcatSpreadable:n}=Symbol,{isArray:o}=Array,{slice:r,unshift:i,shift:a}=Array.prototype;function s(e){if(!function(e){return"object"==typeof e?null!==e:"function"==typeof e}(e))return!1;const t=e[n];return void 0!==t?Boolean(t):o(e)}function l(...e){const t=Object(this),n=[];let o=0;const l=r.call(arguments);for(i.call(l,t);l.length;){const e=a.call(l);if(s(e)){let t=0;const r=e.length;for(;t<r;t+=1,o+=1)if(t in e){const r=e[t];n[o]=r}}else n[o]=e,o+=1}return n}function c(e){return void 0===Object.getOwnPropertyDescriptor(Element.prototype,e)}(function(){if("getKey"in Proxy)return!1;const e=new Proxy([3,4],{});return 4!==[1,2].concat(e).length})()&&(Array.prototype.concat=l);var u=Object.freeze({invariant:function(e,t){if(!e)throw new Error(`Invariant Violation: ${t}`)},isTrue:function(e,t){if(!e)throw new Error(`Assert Violation: ${t}`)},isFalse:function(e,t){if(e)throw new Error(`Assert Violation: ${t}`)},fail:function(e){throw new Error(e)}});const{assign:d,create:f,defineProperties:h,defineProperty:p,freeze:m,getOwnPropertyDescriptor:g,getOwnPropertyNames:y,getPrototypeOf:v,hasOwnProperty:b,keys:w,seal:$,setPrototypeOf:T}=Object,{isArray:E}=Array,{constructor:k,filter:C,find:x,forEach:R,indexOf:S,join:A,map:O,push:M,reduce:P,reverse:L,slice:H,splice:I,unshift:N}=Array.prototype,{charCodeAt:j,replace:D,slice:F,toLowerCase:B}=String.prototype;function _(e){return void 0===e}function q(e){return null===e}function V(e){return!0===e}function z(e){return!1===e}function W(e){return"function"==typeof e}function K(e){return"object"==typeof e}function U(e){return"string"==typeof e}const Y={}.toString;function G(e){return e&&e.toString?E(e)?A.call(O.call(e,G),","):e.toString():"object"==typeof e?Y.call(e):e+Q}function J(e,t){do{const n=g(e,t);if(!_(n))return n;e=v(e)}while(null!==e)}const Q="",X="Symbol(x)"===Symbol("x").toString();const Z=new WeakMap;var ee=Object.freeze({createFieldName:function(e,t){return X?Symbol(e):`$$lwc-${t}-${e}$$`},setHiddenField:function(e,t,n){let o=Z.get(e);_(o)&&(o=f(null),Z.set(e,o)),o[t]=n},getHiddenField:function(e,t){const n=Z.get(e);if(!_(n))return n[t]}});const{hasAttribute:te,getAttribute:ne,setAttribute:oe,setAttributeNS:re,removeAttribute:ie,removeAttributeNS:ae}=Element.prototype,se=g(Element.prototype,"tagName").get,le=/^aria/,ce=new WeakMap,{hasOwnProperty:ue}=Object.prototype,{replace:de,toLowerCase:fe}=String.prototype;function he(e){let t=ce.get(e);return void 0===t&&(t={},ce.set(e,t)),t}function pe(e){const t=de.call(e,le,"aria-"),n=function(e,t){return{get(){const n=he(this);return ue.call(n,e)?n[e]:te.call(this,t)?ne.call(this,t):null},set(n){const o=null==(r=n)?null:r+"";var r;he(this)[e]=o,null===n?ie.call(this,t):oe.call(this,t,n)},configurable:!0,enumerable:!0}}(e,fe.call(t));Object.defineProperty(Element.prototype,e,n)}const me=["ariaAutoComplete","ariaChecked","ariaCurrent","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaInvalid","ariaLabel","ariaLevel","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPressed","ariaReadOnly","ariaRequired","ariaSelected","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","ariaLive","ariaRelevant","ariaAtomic","ariaBusy","ariaActiveDescendant","ariaControls","ariaDescribedBy","ariaFlowTo","ariaLabelledBy","ariaOwns","ariaPosInSet","ariaSetSize","ariaColCount","ariaColIndex","ariaDetails","ariaErrorMessage","ariaKeyShortcuts","ariaModal","ariaPlaceholder","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaColSpan","role"];for(let e=0,t=me.length;e<t;e+=1){const t=me[e];c(t)&&pe(t)}const ge=["accessKey","dir","draggable","hidden","id","lang","tabIndex","title"];function ye(e){return`Using the \`${e}\` property is an anti-pattern because it rounds the value to an integer. Instead, use the \`getBoundingClientRect\` method to obtain fractional values for the size of an element and its position relative to the viewport.`}const ve=d(f(null),{accessKey:{attribute:"accesskey"},accessKeyLabel:{readOnly:!0},className:{attribute:"class",error:"Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead."},contentEditable:{attribute:"contenteditable"},dataset:{readOnly:!0,error:"Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."},dir:{attribute:"dir"},draggable:{attribute:"draggable"},dropzone:{attribute:"dropzone",readOnly:!0},hidden:{attribute:"hidden"},id:{attribute:"id"},inputMode:{attribute:"inputmode"},lang:{attribute:"lang"},slot:{attribute:"slot",error:"Using the `slot` property is an anti-pattern."},spellcheck:{attribute:"spellcheck"},style:{attribute:"style"},tabIndex:{attribute:"tabindex"},title:{attribute:"title"},translate:{attribute:"translate"},isContentEditable:{readOnly:!0},offsetHeight:{readOnly:!0,error:ye("offsetHeight")},offsetLeft:{readOnly:!0,error:ye("offsetLeft")},offsetParent:{readOnly:!0},offsetTop:{readOnly:!0,error:ye("offsetTop")},offsetWidth:{readOnly:!0,error:ye("offsetWidth")},role:{attribute:"role"}}),be=f(null),we=f(null);R.call(me,e=>{const t=B.call(D.call(e,/^aria/,"aria-"));be[t]=e,we[e]=t}),R.call(ge,e=>{const t=B.call(e);be[t]=e,we[e]=t}),R.call(["accessKey","readOnly","tabIndex","bgColor","colSpan","rowSpan","contentEditable","dateTime","formAction","isMap","maxLength","useMap"],e=>{const t=B.call(e);be[t]=e,we[e]=t});const $e=/-([a-z])/g;const Te=/[A-Z]/g;function Ee(e){return _(we[e])&&(we[e]=D.call(e,Te,e=>"-"+e.toLowerCase())),we[e]}let ke,Ce=null;function xe(e,t){Ce=null,ke=void 0}function Re(e,t){Ce=e,ke=t}const{createFieldName:Se}=ee;let Ae=[];const Oe=$(f(null)),Me=$([]),Pe=Se("ViewModel","engine");function Le(){if(0===Ae.length)throw new Error("Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.");const e=Ae;Ae=[];for(let t=0,n=e.length;t<n;t+=1)e[t]()}function He(e){if(!W(e))throw new Error("Internal Error: addCallbackToNextTick() can only accept a function callback");0===Ae.length&&Promise.resolve().then(Le),M.call(Ae,e)}function Ie(e){return b.call(e,"__circular__")}function Ne(e){if(!W(e))throw new TypeError("Circular module dependency must be a function.");return e()}const je=b.call(Element.prototype,"$shadowToken$");function De(e,t){let n=`[LWC error]: ${e}`;t&&(n=`${n}\n${function(e){const t=[];let n="",o=e;do{M.call(t,`${n}<${B.call(se.call(o))}>`),n+="\t";const e=o.getRootNode();o=e===o||e===document?null:e instanceof ShadowRoot?e.host:e}while(!q(o));return A.call(t,"\n")}(t)}`);try{throw new Error(n)}catch(e){console.error(e)}}function Fe(e){const{data:{on:t}}=e;if(_(t))return;const n=e.elm,o=e.listener=function e(t){!function(e,t){const{type:n}=e,{data:{on:o}}=t,r=o&&o[n];r&&r.call(void 0,e)}(t,e.vnode)};let r;for(r in o.vnode=e,t)n.addEventListener(r,o)}var Be={update:function(e,t){_(e.listener)?Fe(t):(t.listener=e.listener,t.listener.vnode=t)},create:Fe};function _e(e,t){const{data:{attrs:n}}=t;if(_(n))return;let{data:{attrs:o}}=e;if(o===n)return;u.invariant(_(o)||w(o).join(",")===w(n).join(","),"vnode.data.attrs cannot change shape.");const r=t.elm;let i;for(i in o=_(o)?Oe:o,n){const e=n[i];o[i]!==e&&(Re(r,i),58===j.call(i,3)?r.setAttributeNS("http://www.w3.org/XML/1998/namespace",i,e):58===j.call(i,5)?r.setAttributeNS("http://www.w3.org/1999/xlink",i,e):q(e)?r.removeAttribute(i):r.setAttribute(i,e),xe())}}const qe={data:{}};var Ve={create:e=>_e(qe,e),update:_e};const ze=f(null);R.call(me,e=>{const t=J(HTMLElement.prototype,e);_(t)||(ze[e]=t)}),R.call(ge,e=>{const t=J(HTMLElement.prototype,e);_(t)||(ze[e]=t)});const{isArray:We}=Array,{getPrototypeOf:Ke,create:Ue,defineProperty:Ye,defineProperties:Ge,isExtensible:Je,getOwnPropertyDescriptor:Qe,getOwnPropertyNames:Xe,getOwnPropertySymbols:Ze,preventExtensions:et,hasOwnProperty:tt}=Object,{push:nt,concat:ot,map:rt}=Array.prototype,it={}.toString;function at(e){return void 0===e}function st(e){return"function"==typeof e}const lt=new WeakMap;function ct(e,t){lt.set(e,t)}const ut=e=>lt.get(e)||e;function dt(e,t){return e.valueIsObservable(t)?e.getProxy(t):t}function ft(e,t,n){ot.call(Xe(n),Ze(n)).forEach(o=>{let r=Qe(n,o);r.configurable||(r=kt(e,r,dt)),Ye(t,o,r)}),et(t)}class ht{constructor(e,t){this.originalTarget=t,this.membrane=e}get(e,t){const{originalTarget:n,membrane:o}=this,r=n[t],{valueObserved:i}=o;return i(n,t),o.getProxy(r)}set(e,t,n){const{originalTarget:o,membrane:{valueMutated:r}}=this;return o[t]!==n?(o[t]=n,r(o,t)):"length"===t&&We(o)&&r(o,t),!0}deleteProperty(e,t){const{originalTarget:n,membrane:{valueMutated:o}}=this;return delete n[t],o(n,t),!0}apply(e,t,n){}construct(e,t,n){}has(e,t){const{originalTarget:n,membrane:{valueObserved:o}}=this;return o(n,t),t in n}ownKeys(e){const{originalTarget:t}=this;return ot.call(Xe(t),Ze(t))}isExtensible(e){const t=Je(e);if(!t)return t;const{originalTarget:n,membrane:o}=this,r=Je(n);return r||ft(o,e,n),r}setPrototypeOf(e,t){throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${n=this.originalTarget,n&&n.toString?n.toString():"object"==typeof n?it.call(n):n+""}. Prototype of reactive objects cannot be changed.`);var n}getPrototypeOf(e){const{originalTarget:t}=this;return Ke(t)}getOwnPropertyDescriptor(e,t){const{originalTarget:n,membrane:o}=this,{valueObserved:r}=this.membrane;r(n,t);let i=Qe(n,t);if(at(i))return i;const a=Qe(e,t);return at(a)?(i=kt(o,i,dt),i.configurable||Ye(e,t,i),i):a}preventExtensions(e){const{originalTarget:t,membrane:n}=this;return ft(n,e,t),et(t),!0}defineProperty(e,t,n){const{originalTarget:o,membrane:r}=this,{valueMutated:i}=r,{configurable:a}=n;if(tt.call(n,"writable")&&!tt.call(n,"value")){const e=Qe(o,t);n.value=e.value}return Ye(o,t,function(e){return tt.call(e,"value")&&(e.value=ut(e.value)),e}(n)),!1===a&&Ye(e,t,kt(r,n,dt)),i(o,t),!0}}function pt(e,t){return e.valueIsObservable(t)?e.getReadOnlyProxy(t):t}class mt{constructor(e,t){this.originalTarget=t,this.membrane=e}get(e,t){const{membrane:n,originalTarget:o}=this,r=o[t],{valueObserved:i}=n;return i(o,t),n.getReadOnlyProxy(r)}set(e,t,n){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot set "${t.toString()}" on "${e}". "${e}" is read-only.`)}}deleteProperty(e,t){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot delete "${t.toString()}" on "${e}". "${e}" is read-only.`)}}apply(e,t,n){}construct(e,t,n){}has(e,t){const{originalTarget:n,membrane:{valueObserved:o}}=this;return o(n,t),t in n}ownKeys(e){const{originalTarget:t}=this;return ot.call(Xe(t),Ze(t))}setPrototypeOf(e,t){{const{originalTarget:e}=this;throw new Error(`Invalid prototype mutation: Cannot set prototype on "${e}". "${e}" prototype is read-only.`)}}getOwnPropertyDescriptor(e,t){const{originalTarget:n,membrane:o}=this,{valueObserved:r}=o;r(n,t);let i=Qe(n,t);if(at(i))return i;const a=Qe(e,t);return at(a)?(i=kt(o,i,pt),tt.call(i,"set")&&(i.set=void 0),i.configurable||Ye(e,t,i),i):a}preventExtensions(e){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot preventExtensions on ${e}". "${e} is read-only.`)}}defineProperty(e,t,n){{const{originalTarget:e}=this;throw new Error(`Invalid mutation: Cannot defineProperty "${t.toString()}" on "${e}". "${e}" is read-only.`)}}}const gt={header:e=>{const t=ut(e);return t&&t!==e?["object",{object:function e(t){if(We(t))return t.map(t=>{const n=ut(t);return n!==t?e(n):t});const n=Ue(Ke(t)),o=Xe(t);return ot.call(o,Ze(t)).reduce((n,o)=>{const r=t[o],i=ut(r);return n[o]=i!==r?e(i):r,n},n)}(e)}]:null},hasBody:()=>!1,body:()=>null};function yt(){return"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==e?e:{}}function vt(e){let t=void 0;return We(e)?t=[]:"object"==typeof e&&(t={}),t}(function(){const e=yt(),t=e.devtoolsFormatters||[];nt.call(t,gt),e.devtoolsFormatters=t})();const bt=Object.prototype;function wt(e){if(null===e)return!1;if("object"!=typeof e)return!1;if(We(e))return!0;const t=Ke(e);return t===bt||null===t||null===Ke(t)}const $t=(e,t)=>{},Tt=(e,t)=>{},Et=e=>e;function kt(e,t,n){const{set:o,get:r}=t;return tt.call(t,"value")?t.value=n(e,t.value):(at(r)||(t.get=function(){return n(e,r.call(ut(this)))}),at(o)||(t.set=function(t){o.call(ut(this),e.unwrapProxy(t))})),t}const{create:Ct}=Object,{splice:xt,indexOf:Rt,push:St}=Array.prototype,At=new WeakMap;function Ot(e){return void 0===e}let Mt=null;function Pt(e,t){const n=At.get(e);if(!Ot(n)){const e=n[t];if(!Ot(e))for(let t=0,n=e.length;t<n;t+=1){e[t].notify()}}}function Lt(e,t){if(null===Mt)return;const n=Mt,o=function(e){let t=At.get(e);if(Ot(t)){const n=Ct(null);t=n,At.set(e,n)}return t}(e);let r=o[t];if(Ot(r))r=[],o[t]=r;else if(r[0]===n)return;-1===Rt.call(r,n)&&n.link(r)}class Ht{constructor(e){this.listeners=[],this.callback=e}observe(e){const t=Mt;let n;Mt=this;try{e()}catch(e){n=Object(e)}finally{if(Mt=t,void 0!==n)throw n}}reset(){const{listeners:e}=this,t=e.length;if(t>0){for(let n=0;n<t;n+=1){const t=e[n],o=Rt.call(e[n],this);xt.call(t,o,1)}e.length=0}}notify(){this.callback.call(void 0,this)}link(e){St.call(e,this),St.call(this.listeners,e)}}function It(e){return e}const Nt=new class{constructor(e){if(this.valueDistortion=Et,this.valueMutated=Tt,this.valueObserved=$t,this.valueIsObservable=wt,this.objectGraph=new WeakMap,!at(e)){const{valueDistortion:t,valueMutated:n,valueObserved:o,valueIsObservable:r}=e;this.valueDistortion=st(t)?t:Et,this.valueMutated=st(n)?n:Tt,this.valueObserved=st(o)?o:$t,this.valueIsObservable=st(r)?r:wt}}getProxy(e){const t=ut(e),n=this.valueDistortion(t);if(this.valueIsObservable(n)){const o=this.getReactiveState(t,n);return o.readOnly===e?e:o.reactive}return n}getReadOnlyProxy(e){e=ut(e);const t=this.valueDistortion(e);return this.valueIsObservable(t)?this.getReactiveState(e,t).readOnly:t}unwrapProxy(e){return ut(e)}getReactiveState(e,t){const{objectGraph:n}=this;let o=n.get(t);if(o)return o;const r=this;return o={get reactive(){const n=new ht(r,t),o=new Proxy(vt(t),n);return ct(o,e),Ye(this,"reactive",{value:o}),o},get readOnly(){const n=new mt(r,t),o=new Proxy(vt(t),n);return ct(o,e),Ye(this,"readOnly",{value:o}),o}},n.set(t,o),o}}({valueObserved:Lt,valueMutated:Pt,valueDistortion:It});function jt(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`)}const Dt=f(null),Ft=f(null);function Bt(e){let t=Dt[e];return _(t)&&(t=Dt[e]=function(){const t=ii(this),{getHook:n}=t;return n(t.component,e)}),t}function _t(e){let t=Ft[e];return _(t)&&(t=Ft[e]=function(t){const n=ii(this),{setHook:o}=n;t=Nt.getReadOnlyProxy(t),o(n.component,e,t)}),t}function qt(e){return function(){const t=ii(this),{callHook:n,component:o}=t,r=o[e];return n(t.component,r,H.call(arguments))}}function Vt(e,t,n){let o;W(e)?o=class extends e{}:(o=function(){throw new TypeError("Illegal constructor")},T(o,e),T(o.prototype,e.prototype),p(o.prototype,"constructor",{writable:!0,configurable:!0,value:o}));const r=f(null);for(let e=0,n=t.length;e<n;e+=1){const n=t[e];r[n]={get:Bt(n),set:_t(n),enumerable:!0,configurable:!0}}for(let e=0,t=n.length;e<t;e+=1){const t=n[e];r[t]={value:qt(t),writable:!0,configurable:!0}}return h(o.prototype,r),o}const zt=Vt(HTMLElement,y(ze),[]);m(zt),$(zt.prototype);const{getHiddenField:Wt}=ee;function Kt(e,t){return"input"===e&&("value"===t||"checked"===t)}function Ut(e,t){const n=t.data.props;if(_(n))return;const o=e.data.props;if(o===n)return;u.invariant(_(o)||w(o).join(",")===w(n).join(","),"vnode.data.props cannot change shape.");const r=t.elm,i=Wt(r,Pe),a=_(o),s=!_(i),{sel:l}=t;for(const e in n){const t=n[e];e in r||u.fail(`Unknown public property "${e}" of element <${l}>. This is likely a typo on the corresponding attribute "${Ee(e)}".`),(a||t!==(Kt(l,e)?r[e]:o[e]))&&(s&&jt(i),r[e]=t)}}const Yt={data:{}};var Gt={create:e=>Ut(Yt,e),update:Ut};const Jt=f(null);function Qt(e){if(null==e)return Oe;e=U(e)?e:e+"";let t=Jt[e];if(t)return t;t=f(null);let n,o=0;const r=e.length;for(n=0;n<r;n++)32===j.call(e,n)&&(n>o&&(t[F.call(e,o,n)]=!0),o=n+1);return n>o&&(t[F.call(e,o,n)]=!0),Jt[e]=t,m(t),t}function Xt(e,t){const{elm:n,data:{className:o}}=t,{data:{className:r}}=e;if(r===o)return;const{classList:i}=n,a=Qt(o),s=Qt(r);let l;for(l in s)_(a[l])&&i.remove(l);for(l in a)_(s[l])&&i.add(l)}const Zt={data:{}};var en={create:e=>Xt(Zt,e),update:Xt};function tn(e,t){const{style:n}=t.data;if(e.data.style===n)return;const o=t.elm,{style:r}=o;U(n)&&""!==n?r.cssText=n:ie.call(o,"style")}const nn={data:{}};var on={create:e=>tn(nn,e),update:tn};var rn={create:function(e){const{elm:t,data:{classMap:n}}=e;if(_(n))return;const{classList:o}=t;for(const e in n)o.add(e)}};var an={create:function(e){const{elm:t,data:{styleMap:n}}=e;if(_(n))return;const{style:o}=t;for(const e in n)o[e]=n[e]}};const{getHiddenField:sn}=ee;const ln={create:function(e){const{data:{context:t}}=e;if(_(t))return;const n=e.elm,o=sn(n,Pe);_(o)||d(o.context,t)}};
/**
@license
Copyright (c) 2015 Simon Friis Vindum.
This code may only be used under the MIT License found at
https://github.com/snabbdom/snabbdom/blob/master/LICENSE
Code distributed by Snabbdom as part of the Snabbdom project at
https://github.com/snabbdom/snabbdom/
*/function cn(e){return void 0===e}function un(e,t){return e.key===t.key&&e.sel===t.sel}function dn(e){return null!=e}function fn(e,t,n){const o={};let r,i,a;for(r=t;r<=n;++r)a=e[r],dn(a)&&(i=a.key,void 0!==i&&(o[i]=r));return o}function hn(e,t,n,o,r){for(;o<=r;++o){const r=n[o];dn(r)&&(r.hook.create(r),r.hook.insert(r,e,t))}}function pn(e,t,n){let o,r,i,a,s=0,l=0,c=t.length-1,u=t[0],d=t[c],f=n.length-1,h=n[0],p=n[f];for(;s<=c&&l<=f;)dn(u)?dn(d)?dn(h)?dn(p)?un(u,h)?(gn(u,h),u=t[++s],h=n[++l]):un(d,p)?(gn(d,p),d=t[--c],p=n[--f]):un(u,p)?(gn(u,p),p.hook.move(u,e,d.elm.nextSibling),u=t[++s],p=n[--f]):un(d,h)?(gn(d,h),h.hook.move(d,e,u.elm),d=t[--c],h=n[++l]):(void 0===o&&(o=fn(t,s,c)),r=o[h.key],cn(r)?(h.hook.create(h),h.hook.insert(h,e,u.elm),h=n[++l]):(i=t[r],dn(i)&&(i.sel!==h.sel?(h.hook.create(h),h.hook.insert(h,e,u.elm)):(gn(i,h),t[r]=void 0,h.hook.move(i,e,u.elm))),h=n[++l])):p=n[--f]:h=n[++l]:d=t[--c]:u=t[++s];if(s<=c||l<=f)if(s>c){const t=n[f+1];a=dn(t)?t.elm:null,hn(e,a,n,l,f)}else!function(e,t,n,o){for(;n<=o;++n){const o=t[n];dn(o)&&o.hook.remove(o,e)}}(e,t,s,c)}function mn(e,t,n){const{length:o}=n;if(0===t.length)return void hn(e,null,n,0,o);let r=null;for(let i=o-1;i>=0;i-=1){const o=n[i],a=t[i];o!==a&&(dn(a)?dn(o)?(gn(a,o),r=o.elm):a.hook.remove(a,e):dn(o)&&(o.hook.create(o),o.hook.insert(o,e,r),r=o.elm))}}function gn(e,t){e!==t&&(t.elm=e.elm,t.hook.update(e,t))}function yn(e){return d({configurable:!0,enumerable:!0,writable:!0},e)}function vn(e){return d({configurable:!0,enumerable:!0},e)}let bn=!1;function wn(){bn=!0}function $n(){bn=!1}function Tn(e,t){return`The \`${e}\` ${t} is available only on elements that use the \`lwc:dom="manual"\` directive.`}function En(e,t){const n=J(e,"textContent"),o=J(e,"nodeValue"),{appendChild:r,insertBefore:i,removeChild:a,replaceChild:s}=e;return{appendChild:yn({value(e){return this instanceof Element&&z(t.isPortal)&&De(Tn("appendChild","method"),this),r.call(this,e)}}),insertBefore:yn({value(e,n){return!bn&&this instanceof Element&&z(t.isPortal)&&De(Tn("insertBefore","method"),this),i.call(this,e,n)}}),removeChild:yn({value(e){return!bn&&this instanceof Element&&z(t.isPortal)&&De(Tn("removeChild","method"),this),a.call(this,e)}}),replaceChild:yn({value(e,n){return this instanceof Element&&z(t.isPortal)&&De(Tn("replaceChild","method"),this),s.call(this,e,n)}}),nodeValue:vn({get(){return o.get.call(this)},set(e){!bn&&this instanceof Element&&z(t.isPortal)&&De(Tn("nodeValue","property"),this),o.set.call(this,e)}}),textContent:vn({get(){return n.get.call(this)},set(e){this instanceof Element&&z(t.isPortal)&&De(Tn("textContent","property"),this),n.set.call(this,e)}})}}function kn(e){e.$fromTemplate$=!0}function Cn(e,t){h(e,function(e,t){const n=En(e,t),o=J(e,"innerHTML"),r=J(e,"outerHTML");return d(n,{innerHTML:vn({get(){return o.get.call(this)},set(e){return z(t.isPortal)&&De(Tn("innerHTML","property"),this),o.set.call(this,e)}}),outerHTML:vn({get(){return r.get.call(this)},set(e){throw new TypeError("Invalid attempt to set outerHTML on Element.")}})}),n}(e,t))}function xn(e,t){h(e,function(e,t){const n=e.querySelector,o=e.querySelectorAll,r=e.addEventListener,i=En(e,t),a=J(e,"innerHTML"),s=J(e,"textContent");return d(i,{innerHTML:vn({get(){return a.get.call(this)},set(e){throw new TypeError("Invalid attempt to set innerHTML on ShadowRoot.")}}),textContent:vn({get(){return s.get.call(this)},set(e){throw new TypeError("Invalid attempt to set textContent on ShadowRoot.")}}),addEventListener:yn({value(t,n,o){return u.invariant(!So,`${Ao}.render() method has side effects on the state of ${G(e)} by adding an event listener for "${t}".`),_(o)||De("The `addEventListener` method in `LightningElement` does not support any options.",this.host),r.apply(this,arguments)}}),querySelector:yn({value(){const e=si(this);return u.isFalse(Mo(e),`this.template.querySelector() cannot be called during the construction of the custom element for ${e} because no content has been rendered yet.`),n.apply(this,arguments)}}),querySelectorAll:yn({value(){const e=si(this);return u.isFalse(Mo(e),`this.template.querySelectorAll() cannot be called during the construction of the custom element for ${e} because no content has been rendered yet.`),o.apply(this,arguments)}})}),R.call(y({cloneNode:0,getElementById:0,getSelection:0,elementsFromPoint:0,dispatchEvent:0}),e=>{const t=vn({get(){throw new Error(`Disallowed method "${e}" in ShadowRoot.`)}});i[e]=t}),i}(e,t))}function Rn(e,t){const n=function(e,t){const n=En(e,t),o=e.addEventListener,r=J(e,"innerHTML"),i=J(e,"outerHTML"),a=J(e,"textContent");return d(n,{innerHTML:vn({get(){return r.get.call(this)},set(e){throw new TypeError("Invalid attempt to set innerHTML on HTMLElement.")}}),outerHTML:vn({get(){return i.get.call(this)},set(e){throw new TypeError("Invalid attempt to set outerHTML on HTMLElement.")}}),textContent:vn({get(){return a.get.call(this)},set(e){throw new TypeError("Invalid attempt to set textContent on HTMLElement.")}}),addEventListener:yn({value(e,t,n){return u.invariant(!So,`${Ao}.render() method has side effects on the state of ${G(this)} by adding an event listener for "${e}".`),_(n)||De("The `addEventListener` method in `LightningElement` does not support any options.",this),o.apply(this,arguments)}})})}(e,t),o=v(e);T(e,f(o,n))}function Sn(e){h(e,{tagName:vn({get(){throw new Error("Usage of property `tagName` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.")},configurable:!0,enumerable:!1})})}const An=()=>{},{getHiddenField:On}=ee;function Mn(e,t){e.$shadowToken$=t}function Pn(e,t){const{text:n}=t;e.text!==n&&(wn(),t.elm.nodeValue=n,$n())}function Ln(e,t,n){wn(),t.insertBefore(e.elm,n),$n()}function Hn(e,t){wn(),t.removeChild(e.elm),$n()}var In;function Nn(e){!function(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isTrue(e.state===Fr.created,`${e} cannot be recycled.`);Xr(e),Gr(e)}(ii(e.elm))}function jn(e,t){const{children:n,owner:o}=t,r=qn(n)?pn:mn;li(o,o.owner,An,()=>{r(t.elm,e.children,n)},An)}function Dn(e){const t=ii(e.elm),{children:n}=e;t.aChildren=n,V(je)&&(!function(e,t){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.invariant(K(e.cmpSlots),"When doing manual allocation, there must be a cmpSlots object available.");const{cmpSlots:n}=e,o=e.cmpSlots=f(null);for(let e=0,n=t.length;e<n;e+=1){const n=t[e];if(q(n))continue;const{data:r}=n,i=r.attrs&&r.attrs.slot||"",a=o[i]=o[i]||[];n.key=`@${i}:${n.key}`,M.call(a,n)}if(z(e.isDirty)){const t=w(n);if(t.length!==w(o).length)return void Do(e);for(let r=0,i=t.length;r<i;r+=1){const i=t[r];if(_(o[i])||n[i].length!==o[i].length)return void Do(e);const a=n[i],s=o[i];for(let t=0,n=o[i].length;t<n;t+=1)if(a[t]!==s[t])return void Do(e)}}}(t,n),e.children=Me)}function Fn(e){const{elm:t,children:n}=e;for(let e=0;e<n.length;++e){const o=n[e];null!=o&&(o.hook.create(o),o.hook.insert(o,t,null))}}function Bn(e){!function(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isTrue(e.state===Fr.connected||e.state===Fr.disconnected,`${e} must have been connected.`);Kr(e)}(ii(e.elm))}!function(e){e.manual="manual"}(In||(In={}));const _n=new WeakMap;function qn(e){return _n.has(e)}const Vn=f(null),zn=["wiring","locator","rendered","connected","disconnected"];function Wn(e,t){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isTrue(E(t)&&t.length>0,"Optimize invokeServiceHook() to be invoked only when needed");const{component:n,data:o,def:r,context:i}=e;for(let e=0,a=t.length;e<a;++e)t[e].call(void 0,n,o,r,i)}const Kn=Symbol.iterator,Un={create:e=>{e.elm=document.createTextNode(e.text),Qn(e),kn(e.elm)},update:Pn,insert:Ln,move:Ln,remove:Hn},Yn={create:e=>{e.elm=document.createComment(e.text),Qn(e),kn(e.elm)},update:Pn,insert:Ln,move:Ln,remove:Hn},Gn={create:e=>{const{data:t,sel:n,clonedElement:o}=e,{ns:r}=t;_(o)?e.elm=_(r)?document.createElement(n):document.createElementNS(r,n):e.elm=o,Qn(e),kn(e.elm),function(e){const{owner:t}=e,n=e.elm;if(V(je)){const{data:{context:o}}=e,{shadowAttribute:r}=t.context;_(o)||_(o.lwc)||o.lwc.dom!==In.manual||function(e){e.$domManual$=!0}(n),Mn(n,r)}{const{data:{context:t}}=e;Cn(n,{isPortal:!_(t)&&!_(t.lwc)&&t.lwc.dom===In.manual})}}(e),function(e){Be.create(e),Ve.create(e),Gt.create(e),rn.create(e),an.create(e),en.create(e),on.create(e),ln.create(e)}(e)},update:(e,t)=>{!function(e,t){Ve.update(e,t),Gt.update(e,t),en.update(e,t),on.update(e,t)}(e,t),jn(e,t)},insert:(e,t,n)=>{Ln(e,t,n),Fn(e)},move:(e,t,n)=>{Ln(e,t,n)},remove:(e,t)=>{Hn(e,t),function(e){const{children:t,elm:n}=e;for(let e=0,o=t.length;e<o;++e){const o=t[e];q(o)||o.hook.remove(o,n)}}(e)}},Jn={create:e=>{const{sel:t}=e;e.elm=document.createElement(t),Qn(e),kn(e.elm),function(e){const t=e.elm;if(!_(On(t,Pe)))return;const{mode:n,ctor:o,owner:r}=e;if(Mr(t,Or(o)),V(je)){const{shadowAttribute:e}=r.context;Mn(t,e)}Yr(t,o,{mode:n,owner:r});const i=ii(t);u.isTrue(i&&"cmpRoot"in i,`${i} is not a vm.`),u.isTrue(E(e.children),"Invalid vnode for a custom element, it must have children defined."),Rn(t,Oe)}(e),Dn(e),function(e){Be.create(e),Ve.create(e),Gt.create(e),rn.create(e),an.create(e),en.create(e),on.create(e),ln.create(e)}(e)},update:(e,t)=>{!function(e,t){Ve.update(e,t),Gt.update(e,t),en.update(e,t),on.update(e,t)}(e,t),Dn(t),jn(e,t),function(e){const t=ii(e.elm);u.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),u.isTrue(E(e.children),"Invalid vnode for a custom element, it must have children defined."),zr(t)}(t)},insert:(e,t,n)=>{Ln(e,t,n),Fn(e),Nn(e)},move:(e,t,n)=>{Ln(e,t,n)},remove:(e,t)=>{Hn(e,t),Bn(e)}};function Qn(e){e.elm.$shadowResolver$=e.owner.cmpRoot.$shadowResolver$}function Xn(e){M.call(Ao.velements,e)}function Zn(e,t,n){u.isTrue(U(e),"h() 1st argument sel must be a string."),u.isTrue(K(t),"h() 2nd argument data must be an object."),u.isTrue(E(n),"h() 3rd argument children must be an array."),u.isTrue("key"in t,` <${e}> "key" attribute is invalid or missing for ${Ao}. Key inside iterator is either undefined or null.`),u.isFalse(t.className&&t.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),u.isFalse(t.styleMap&&t.style,"vnode.data.styleMap and vnode.data.style ambiguous declaration."),t.style&&!U(t.style)&&De(`Invalid 'style' attribute passed to <${e}> is ignored. This attribute must be a string value.`,Ao.elm),R.call(n,e=>{null!=e&&u.isTrue(e&&"sel"in e&&"data"in e&&"children"in e&&"text"in e&&"elm"in e&&"key"in e,`${e} is not a vnode.`)});const{key:o}=t;const r={sel:e,data:t,children:n,text:void 0,elm:void 0,key:o,hook:Gn,owner:Ao};return 3===e.length&&115===j.call(e,0)&&118===j.call(e,1)&&103===j.call(e,2)&&function e(t){const{data:n,children:o,sel:r}=t;if(n.ns="http://www.w3.org/2000/svg",E(o)&&"foreignObject"!==r)for(let t=0,n=o.length;t<n;++t){const n=o[t];null!=n&&n.hook===Gn&&e(n)}}(r),r}function eo(e,t,n,o){Ie(t)&&(t=Ne(t)),u.isTrue(U(e),"c() 1st argument sel must be a string."),u.isTrue(W(t),"c() 2nd argument Ctor must be a function."),u.isTrue(K(n),"c() 3nd argument data must be an object."),u.isTrue(3===arguments.length||E(o),"c() 4nd argument data must be an array."),u.isFalse(n.className&&n.classMap,"vnode.data.className and vnode.data.classMap ambiguous declaration."),u.isFalse(n.styleMap&&n.style,"vnode.data.styleMap and vnode.data.style ambiguous declaration."),n.style&&!U(n.style)&&De(`Invalid 'style' attribute passed to <${e}> is ignored. This attribute must be a string value.`,Ao.elm),4===arguments.length&&R.call(o,e=>{null!=e&&u.isTrue(e&&"sel"in e&&"data"in e&&"children"in e&&"text"in e&&"elm"in e&&"key"in e,`${e} is not a vnode.`)});const{key:r}=n;let i,a;const s={sel:e,data:n,children:o=3===arguments.length?Me:o,text:i,elm:a,key:r,hook:Jn,ctor:t,owner:Ao,mode:"open"};return Xn(s),s}function to(e){return{sel:void 0,data:Oe,children:void 0,text:e,elm:void 0,key:void 0,hook:Un,owner:Ao}}function no(e){if(q(Ao))throw new Error;const t=Ao;return function(n){Lo(t,e,t.component,n)}}const oo=new Map;let ro=0;function io(e){var t;return u.isTrue(E(e),"sc() api can only work with arrays."),t=e,_n.set(t,1),e}var ao=Object.freeze({h:Zn,ti:function(e){const t=e>0&&!(V(e)||z(e));return t&&De(`Invalid tabindex value \`${G(e)}\` in template for ${Ao}. This attribute must be set to 0 or -1.`,Ao.elm),t?0:e},s:function(e,t,n,o){u.isTrue(U(e),"s() 1st argument slotName must be a string."),u.isTrue(K(t),"s() 2nd argument data must be an object."),u.isTrue(E(n),"h() 3rd argument children must be an array."),_(o)||_(o[e])||0===o[e].length||(n=o[e]);const r=Zn("slot",t,n);return je&&io(n),r},c:eo,i:function(e,t){const n=[];if(io(n),_(e)||null===e)return De(`Invalid template iteration for value "${G(e)}" in ${Ao}. It must be an Array or an iterable Object.`,Ao.elm),n;u.isFalse(_(e[Kn]),`Invalid template iteration for value \`${G(e)}\` in ${Ao}. It must be an array-like object and not \`null\` nor \`undefined\`.`);const o=e[Kn]();u.isTrue(o&&W(o.next),`Invalid iterator function for "${G(e)}" in ${Ao}.`);let r,i,a=o.next(),s=0,{value:l,done:c}=a;for(r=f(null);!1===c;){a=o.next(),c=a.done;const e=t(l,s,0===s,c);E(e)?M.apply(n,e):M.call(n,e);{const t=E(e)?e:[e];R.call(t,e=>{if(!q(e)&&K(e)&&!_(e.sel)){const{key:t}=e;U(t)||"number"==typeof t?(1===r[t]&&_(i)&&(i=`Duplicated "key" attribute value for "<${e.sel}>" in ${Ao} for item number ${s}. A key with value "${e.key}" appears more than once in the iteration. Key values must be unique numbers or strings.`),r[t]=1):_(i)&&(i=`Invalid "key" attribute value in "<${e.sel}>" in ${Ao} for item number ${s}. Set a unique "key" value on all iterated child elements.`)}})}s+=1,l=a.value}return _(i)||De(i,Ao.elm),n},f:function(e){u.isTrue(E(e),"flattening api can only work with arrays.");const t=e.length,n=[];io(n);for(let o=0;o<t;o+=1){const t=e[o];E(t)?M.apply(n,t):M.call(n,t)}return n},t:to,p:function(e){return{sel:"!",data:Oe,children:void 0,text:e,elm:void 0,key:void 0,hook:Yn,owner:Ao}},d:function(e){return null==e?null:to(e)},b:no,fb:function(e){if(q(Ao))throw new Error;const t=Ao;return function(){return Po(t,e,H.call(arguments))}},ll:function(e,t,n){if(q(Ao))throw new Error;const o=Ao,r=no(e);return function(e){const{context:{locator:i}}=o;if(!_(i)){const{locator:e}=Vn;e&&(i.resolved={target:t,host:i.id,targetContext:W(n)&&n(),hostContext:W(i.context)&&i.context()},Wn(o,e))}r(e)}},k:function(e,t){switch(typeof t){case"number":case"string":return e+":"+t;case"object":u.fail(`Invalid key value "${t}" in ${Ao}. Key must be a string or number.`)}},gid:function(e){return _(e)||""===e?(De(`Invalid id value "${e}". The id attribute must contain a non-empty string.`,Ao.elm),e):q(e)?null:`${e}-${Ao.idx}`},fid:function(e){return _(e)||""===e?(_(e)&&De('Undefined url value for "href" or "xlink:href" attribute. Expected a non-empty string.',Ao.elm),e):q(e)?null:/^#/.test(e)?`${e}-${Ao.idx}`:e},dc:function(e,t,n,o){if(u.isTrue(U(e),"dc() 1st argument sel must be a string."),u.isTrue(K(n),"dc() 3nd argument data must be an object."),u.isTrue(3===arguments.length||E(o),"dc() 4nd argument data must be an array."),null==t)return null;if(!Ar(t))throw new Error(`Invalid LWC Constructor ${G(t)} for custom element <${e}>.`);let r=oo.get(t);return _(r)&&(r=ro++,oo.set(t,r)),n.key=`dc:${r}:${n.key}`,eo(e,t,n,o)},sc:io});const so=new Set;function lo(){return[]}so.add(lo);const co=f(null);function uo(e){const t=document.createElement("style");return t.type="text/css",t.textContent=e,t}const fo=document.head||document.body||document,ho=f(null);function po(e,t,n,o,r){R.call(e,e=>{E(e)?po(e,t,n,o,r):r(e(t,n,o))})}function mo(e,t,n,o){if(u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isTrue(E(t),"Invalid stylesheets."),je){return po(t,`[${n}]`,`[${o}]`,!1,e=>{!function(e){if(_(ho[e])){ho[e]=!0;const t=uo(e);fo.appendChild(t)}}(e)}),null}{let e="";return po(t,Q,Q,!0,t=>{e+=t}),function(e){const t=Zn("style",{key:"style"},Me);return t.clonedElement=e,t}(function(e){let t=co[e];if(_(t)){t=document.createDocumentFragment();const n=uo(e);t.appendChild(n),co[e]=t}return t.cloneNode(!0).firstChild}(e))}}const go=f(null);function yo(e,t){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isTrue(W(t),`evaluateTemplate() second argument must be an imported template instead of ${G(t)}`);const{component:n,context:o,cmpSlots:r,cmpTemplate:i}=e;if(t!==i){if(_(i)||ei(e),a=t,!so.has(a))throw new TypeError(`Invalid template returned by the render() method on ${e}. It must return an imported template (e.g.: \`import html from "./${e.def.name}.html"\`), instead, it has returned: ${G(t)}.`);e.cmpTemplate=t,o.tplCache=f(null),function(e){const{context:t,elm:n}=e,o=t.hostAttribute;_(o)||ie.call(n,o),t.hostAttribute=t.shadowAttribute=void 0}(e);const{stylesheets:n,stylesheetTokens:r}=t;if(_(n)||0===n.length)o.styleVNode=null;else if(!_(r)){const{hostAttribute:t,shadowAttribute:i}=r;!function(e,t,n){const{context:o,elm:r}=e;oe.call(r,t,""),o.hostAttribute=t,o.shadowAttribute=n}(e,t,i),o.styleVNode=mo(e,n,t,i)}(function(e,t){const{component:n}=e,{ids:o=[]}=t;R.call(o,t=>{t in n||De(`The template rendered by ${e} references \`this.${t}\`, which is not declared. Check for a typo in the template.`,e.elm)})})(e,t)}var a;u.isTrue(K(o.tplCache),`vm.context.tplCache must be an object associated to ${i}.`),function(e,t){const{cmpSlots:n=go}=e,{slots:o=Me}=t;for(const t in n)u.isTrue(E(n[t]),`Slots can only be set to an array, instead received ${G(n[t])} for slot "${t}" in ${e}.`),""!==t&&-1===S.call(o,t)&&De(`Ignoring unknown provided slot name "${t}" in ${e}. Check for a typo on the slot attribute.`,e.elm)}(e,t),e.velements=[];const s=t.call(void 0,ao,n,r,o.tplCache),{styleVNode:l}=o;return q(l)||N.call(s,l),u.invariant(E(s),"Compiler should produce html functions that always return an array."),s}var vo;!function(e){e.REHYDRATE="lwc-rehydrate",e.HYDRATE="lwc-hydrate"}(vo||(vo={}));const bo="undefined"!=typeof performance&&"function"==typeof performance.mark&&"function"==typeof performance.clearMarks&&"function"==typeof performance.measure&&"function"==typeof performance.clearMeasures;function wo(e,t){return`<${B.call(se.call(t.elm))} (${t.idx})> - ${e}`}function $o(e){performance.mark(e)}function To(e,t){performance.measure(e,t),performance.clearMarks(t),performance.clearMarks(e)}function Eo(){}const ko=bo?function(e,t){$o(wo(e,t))}:Eo,Co=bo?function(e,t){const n=wo(e,t);To(n,n)}:Eo,xo=bo?function(e,t){$o(_(t)?e:wo(e,t))}:Eo,Ro=bo?function(e,t){To(e,_(t)?e:wo(e,t))}:Eo;let So=!1,Ao=null,Oo=null;function Mo(e){return u.isTrue(e&&"cmpProps"in e,`${e} is not a vm.`),Oo===e}function Po(e,t,n){const{component:o,callHook:r,context:i,owner:a}=e;let s;return li(e,a,()=>{},()=>{s=r(o,t,n)},()=>{}),s}function Lo(e,t,n,o){const{callHook:r,owner:i,context:a}=e;li(e,i,()=>{},()=>{u.isTrue(W(t),`Invalid event handler for event '${o.type}' on ${e}.`),r(n,t,[o])},()=>{})}const Ho=new Map;function Io(e,t){if(u.isTrue(e&&"cmpProps"in e,`${e} is not a vm.`),function(e,t){const n=Oo;let o;u.isTrue(e&&"cmpProps"in e,`${e} is not a vm.`),ko("constructor",e),Oo=e;try{const r=new t;if(Oo.component!==r)throw new TypeError("Invalid component constructor, the class should extend LightningElement.")}catch(e){o=Object(e)}finally{if(Co("constructor",e),Oo=n,!_(o))throw o.wcStack=oi(e.elm),o}}(e,t),_(e.component))throw new ReferenceError(`Invalid construction for ${t}, you must extend LightningElement.`)}function No(e){return new Ht(()=>{u.invariant(!So,`Mutating property is not allowed during the rendering life-cycle of ${Ao}.`);const{isDirty:t}=e;z(t)&&(Do(e),function(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);e.isScheduled||(e.isScheduled=!0,0===Jr.length&&He(Qr),M.call(Jr,e))}(e))})}function jo(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.invariant(e.isDirty,`${e} is not dirty.`),e.tro.reset();const t=function(e){const{def:{render:t},callHook:n,component:o,context:r,owner:i}=e,a=So,s=Ao;let l;return So=!0,Ao=e,li(e,i,()=>{ko("render",e),So=!0,Ao=e},()=>{e.tro.observe(()=>{const r=n(o,t);l=yo(e,r)})},()=>{Co("render",e),So=a,Ao=s}),l||[]}(e);return e.isDirty=!1,e.isScheduled=!1,u.invariant(E(t),`${e}.render() should always return an array of vnodes instead of ${t}`),t}function Do(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isFalse(e.isDirty,`markComponentAsDirty() for ${e} should not be called when the component is already dirty.`),u.isFalse(So,`markComponentAsDirty() for ${e} cannot be called during rendering of ${Ao}.`),e.isDirty=!0}const Fo=new WeakMap;function Bo(e,t){if(u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),!W(t))throw new TypeError;let n=Fo.get(t);return _(n)&&(n=function(n){Lo(e,t,void 0,n)},Fo.set(t,n)),n}function _o(e){const t=ai(e);return`<${B.call(se.call(t.elm))}>`}function qo(e){return P.call(e,(e,t)=>{var n;return e[t]=(n=t,{get(){const e=ai(this);return u.isTrue(e&&"cmpRoot"in e,`${e} is not a valid vm.`),Lt(this,n),e.cmpTrack[n]},set(e){const t=ai(this);u.isTrue(t&&"cmpRoot"in t,`${t} is not a valid vm.`),e!==t.cmpTrack[n]&&(t.cmpTrack[n]=e,z(t.isDirty)&&Pt(this,n))},enumerable:!0,configurable:!0}),e},{})}const Vo=g(ShadowRoot.prototype,"host").get,zo=g(ShadowRoot.prototype,"innerHTML").set,Wo="EventTarget"in window?EventTarget.prototype.dispatchEvent:Node.prototype.dispatchEvent,Ko=Event,{setHiddenField:Uo}=ee;function Yo(e){return ai(e).elm}function Go(){if(q(Oo))throw new ReferenceError;u.isTrue("cmpProps"in Oo,`${Oo} is not a vm.`),u.invariant(Oo.elm instanceof HTMLElement,`Component creation requires a DOM element to be associated to ${Oo}.`);const e=Oo,{elm:t,mode:n,def:{ctor:o}}=e,r=this;if(e.component=r,e.tro=No(e),e.oar=f(null),1===arguments.length){const{callHook:t,setHook:n,getHook:o}=arguments[0];e.callHook=t,e.setHook=n,e.getHook=o}const i={mode:n,delegatesFocus:!!o.delegatesFocus},a=t.attachShadow(i);return Uo(r,Pe,e),Uo(a,Pe,e),Uo(t,Pe,e),e.cmpRoot=a,Sn(r),xn(a,Oe),this}Go.prototype={constructor:Go,dispatchEvent(e){const t=Yo(this),n=ai(this);{if(0===arguments.length)throw new Error(`Failed to execute 'dispatchEvent' on ${_o(this)}: 1 argument required, but only 0 present.`);if(!(e instanceof Ko))throw new Error(`Failed to execute 'dispatchEvent' on ${_o(this)}: parameter 1 is not of type 'Event'.`);const{type:o}=e;u.isFalse(Mo(n),`this.dispatchEvent() should not be called during the construction of the custom element for ${_o(this)} because no one is listening for the event "${o}" just yet.`),/^[a-z][a-z0-9_]*$/.test(o)||De(`Invalid event type "${o}" dispatched in element ${_o(this)}. Event name must ${["1) Start with a lowercase letter","2) Contain only lowercase letters, numbers, and underscores"].join(" ")}`,t)}return Wo.call(t,e)},addEventListener(e,t,n){const o=ai(this);u.isTrue(o&&"cmpRoot"in o,`${o} is not a vm.`),u.invariant(!So,`${Ao}.render() method has side effects on the state of ${o} by adding an event listener for "${e}".`),u.invariant(W(t),`Invalid second argument for this.addEventListener() in ${o} for event "${e}". Expected an EventListener but received ${t}.`);const r=Bo(o,t);o.elm.addEventListener(e,r,n)},removeEventListener(e,t,n){const o=ai(this);u.isTrue(o&&"cmpRoot"in o,`${o} is not a vm.`);const r=Bo(o,t);o.elm.removeEventListener(e,r,n)},setAttributeNS(e,t,n){const o=Yo(this);u.isFalse(Mo(ai(this)),`Failed to construct '${_o(this)}': The result must not have attributes.`),Re(o,t),o.setAttributeNS.apply(o,arguments),xe()},removeAttributeNS(e,t){const n=Yo(this);Re(n,t),n.removeAttributeNS.apply(n,arguments),xe()},removeAttribute(e){const t=Yo(this);Re(t,e),t.removeAttribute.apply(t,arguments),xe()},setAttribute(e,t){const n=Yo(this);u.isFalse(Mo(ai(this)),`Failed to construct '${_o(this)}': The result must not have attributes.`),Re(n,e),n.setAttribute.apply(n,arguments),xe()},getAttribute(e){const t=Yo(this);Re(t,e);const n=t.getAttribute.apply(t,arguments);return xe(),n},getAttributeNS(e,t){const n=Yo(this);Re(n,t);const o=n.getAttributeNS.apply(n,arguments);return xe(),o},getBoundingClientRect(){const e=Yo(this);{const e=ai(this);u.isFalse(Mo(e),`this.getBoundingClientRect() should not be called during the construction of the custom element for ${_o(this)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`)}return e.getBoundingClientRect()},querySelector(e){const t=ai(this);u.isFalse(Mo(t),`this.querySelector() cannot be called during the construction of the custom element for ${_o(this)} because no children has been added to this element yet.`);const{elm:n}=t;return n.querySelector(e)},querySelectorAll(e){const t=ai(this);u.isFalse(Mo(t),`this.querySelectorAll() cannot be called during the construction of the custom element for ${_o(this)} because no children has been added to this element yet.`);const{elm:n}=t;return n.querySelectorAll(e)},getElementsByTagName(e){const t=ai(this);u.isFalse(Mo(t),`this.getElementsByTagName() cannot be called during the construction of the custom element for ${_o(this)} because no children has been added to this element yet.`);const{elm:n}=t;return n.getElementsByTagName(e)},getElementsByClassName(e){const t=ai(this);u.isFalse(Mo(t),`this.getElementsByClassName() cannot be called during the construction of the custom element for ${_o(this)} because no children has been added to this element yet.`);const{elm:n}=t;return n.getElementsByClassName(e)},get classList(){{const e=ai(this);u.isFalse(Mo(e),`Failed to construct ${e}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`)}return Yo(this).classList},get template(){const e=ai(this);return u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),e.cmpRoot},get shadowRoot(){return null},render(){return ai(this).def.template},toString(){const e=ai(this);return u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),`[object ${e.def.name}]`}};const Jo=P.call(y(ze),(e,t)=>(e[t]=function(e,t){const{get:n,set:o,enumerable:r,configurable:i}=t;if(!W(n))throw u.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${e} definition. Missing the standard getter.`),new TypeError;if(!W(o))throw u.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${e} definition. Missing the standard setter.`),new TypeError;return{enumerable:r,configurable:i,get(){const t=ai(this);if(u.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`),!Mo(t))return Lt(this,e),n.call(t.elm);{const n=t.elm.constructor.name;De(`\`${n}\` constructor can't read the value of property \`${e}\` because the owner component hasn't set the value yet. Instead, use the \`${n}\` constructor to set a default value for the property.`,t.elm)}},set(t){const n=ai(this);return u.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),u.invariant(!So,`${Ao}.render() method has side effects on the state of ${n}.${e}`),u.isFalse(Mo(n),`Failed to construct '${_o(this)}': The result must not have attributes.`),u.invariant(!K(t)||q(t),`Invalid value "${t}" for "${e}" of ${n}. Value cannot be an object, must be a primitive value.`),t!==n.cmpProps[e]&&(n.cmpProps[e]=t,z(n.isDirty)&&Pt(this,e)),o.call(n.elm,t)}}}(t,ze[t]),e),f(null));var Qo;h(Go.prototype,Jo),Qo=Go.prototype,h(Qo,function(e){const t={};return R.call(y(ve),n=>{n in e||(t[n]=vn({get(){const{error:e,attribute:t}=ve[n],o=[];o.push(`Accessing the global HTML property "${n}" is disabled.`),e?o.push(e):t&&o.push(`Instead access it via \`this.getAttribute("${t}")\`.`),De(o.join("\n"),ai(this).elm)},set(){const{readOnly:e}=ve[n];e&&De(`The global HTML property \`${n}\` is read-only.`)}}))}),t}(Qo)),m(Go),$(Go.prototype);const Xo=Go;function Zo(e,t,n){if(1===arguments.length)return Nt.getProxy(e);if(3!==arguments.length&&u.fail("@track decorator can only be used with one argument to return a trackable object, or as a decorator function."),!_(n)){const{get:e,set:t,configurable:o,writable:r}=n;u.isTrue(!e&&!t,"Compiler Error: A @track decorator can only be applied to a public field."),u.isTrue(!1!==o,"Compiler Error: A @track decorator can only be applied to a configurable property."),u.isTrue(!1!==r,"Compiler Error: A @track decorator can only be applied to a writable property.")}return er(e,t,!!_(n)||!0===n.enumerable)}function er(e,t,n){return{get(){const e=ai(this);return u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),Lt(this,t),e.cmpTrack[t]},set(e){const n=ai(this);u.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),u.invariant(!So,`${Ao}.render() method has side effects on the state of ${n}.${String(t)}`);const o=Nt.getProxy(e);o!==n.cmpTrack[t]&&(n.cmpTrack[t]=o,z(n.isDirty)&&Pt(this,t))},enumerable:n,configurable:!0}}function tr(e,t,n){if(!_(n)){const{get:e,set:t,configurable:o,writable:r}=n;u.isTrue(!e&&!t,"Compiler Error: A @wire decorator can only be applied to a public field."),u.isTrue(!1!==o,"Compiler Error: A @wire decorator can only be applied to a configurable property."),u.isTrue(!1!==r,"Compiler Error: A @wire decorator can only be applied to a writable property.")}return er(0,t,!K(n)||!0===n.enumerable)}function nr(e,t){const n=arguments.length;if(n>0&&n<3)return tr;throw u.fail("@wire(adapter, config?) may only be used as a decorator."),new TypeError}const{assign:or,create:rr,defineProperties:ir,defineProperty:ar,freeze:sr,getOwnPropertyDescriptor:lr,getOwnPropertyNames:cr,getPrototypeOf:ur,hasOwnProperty:dr,keys:fr,seal:hr,setPrototypeOf:pr}=Object;function mr(e){return void 0===e}Symbol("x").toString();const gr=rr(null);function yr(e,t){if(!(!0===t||function(e){return!1===e}(t))){const n=`Invalid ${typeof t} value specified for the "${e}" flag. Runtime feature flags can only be set to a boolean value.`;throw new TypeError(n)}mr(vr[e])?console.warn(`LWC feature flag "${e}" is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`):gr[e]=t}const vr={ENABLE_REACTIVE_SETTER:null,ENABLE_ELEMENT_PATCH:null,ENABLE_NODE_LIST_PATCH:null,ENABLE_HTML_COLLECTIONS_PATCH:null,ENABLE_NODE_PATCH:null};function br(e,t,n){3!==arguments.length&&u.fail("@api decorator can only be used as a decorator function."),u.invariant(!n||W(n.get)||W(n.set),`Invalid property ${G(t)} definition in ${e}, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`),K(n)&&W(n.set)&&u.isTrue(K(n)&&W(n.get),`Missing getter for property ${G(t)} decorated with @api in ${e}. You cannot have a setter without the corresponding getter.`);const o=Cr(e);return K(n)&&(W(n.get)||W(n.set))?(o.props[t].config=W(n.set)?3:1,Tr(e,t,n)):(o.props[t].config=0,wr(e,t,n))}function wr(e,t,n){return{get(){const e=ai(this);if(u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),!Mo(e))return Lt(this,t),e.cmpProps[t];{const n=e.elm.constructor.name;De(`\`${n}\` constructor can’t read the value of property \`${G(t)}\` because the owner component hasn’t set the value yet. Instead, use the \`${n}\` constructor to set a default value for the property.`,e.elm)}},set(e){const n=ai(this);u.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),u.invariant(!So,`${Ao}.render() method has side effects on the state of ${n}.${G(t)}`),n.cmpProps[t]=e,z(n.isDirty)&&Pt(this,t)},enumerable:!!_(n)||n.enumerable}}class $r extends Ht{constructor(e,t){super(()=>{z(this.debouncing)&&(this.debouncing=!0,He(()=>{if(V(this.debouncing)){const{value:n}=this,{isDirty:o,component:r,idx:i}=e;t.call(r,n),this.debouncing=!1,V(e.isDirty)&&z(o)&&i>0&&zr(e)}}))}),this.debouncing=!1}reset(e){super.reset(),this.debouncing=!1,arguments.length>0&&(this.value=e)}}function Tr(e,t,n){const{get:o,set:r,enumerable:i}=n;if(!W(o))throw u.fail(`Invalid attempt to create public property descriptor ${G(t)} in ${e}. It is missing the getter declaration with @api get ${G(t)}() {} syntax.`),new TypeError;return{get(){{const e=ai(this);u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`)}return o.call(this)},set(e){const n=ai(this);if(u.isTrue(n&&"cmpRoot"in n,`${n} is not a vm.`),u.invariant(!So,`${Ao}.render() method has side effects on the state of ${n}.${G(t)}`),r)if(gr.ENABLE_REACTIVE_SETTER){let o=n.oar[t];_(o)&&(o=n.oar[t]=new $r(n,r)),o.reset(e),o.observe(()=>{r.call(this,e)})}else r.call(this,e);else u.fail(`Invalid attempt to set a new value for property ${G(t)} of ${n} that does not has a setter decorated with @api.`)},enumerable:i}}function Er(e,t){if(!W(e)||null==t)throw new TypeError;const n=y(t),o=e.prototype;for(let r=0,i=n.length;r<i;r+=1){const i=n[r],a=t[i];if(!W(a))throw new TypeError;const s=a(e,i,g(o,i));_(s)||p(o,i,s)}return e}const kr=new Map;function Cr(e){return kr.get(e)}const xr=new WeakMap,{getHiddenField:Rr}=ee;function Sr(e,t,n){{const t=e.name;u.isTrue(e.constructor,`Missing ${t}.constructor, ${t} should have a "constructor" property.`)}const{name:o}=t;let{template:r}=t;const i=Cr(e);let a,s,l={},c={},p={};_(i)||(l=i.props,c=i.methods,a=i.wire,p=i.track,s=i.fields);const g=e.prototype;let{connectedCallback:b,disconnectedCallback:w,renderedCallback:$,errorCallback:T,render:E}=g;const k=function(e,t){let n=v(e);if(q(n))throw new ReferenceError(`Invalid prototype chain for ${t}, you must extend LightningElement.`);if(Ie(n)){const e=Ne(n);if(q(e))throw new ReferenceError(`Circular module dependency for ${t}, must resolve to a constructor that extends LightningElement.`);n=e===n?Xo:e}return n}(e,n),C=k!==Xo?Or(k,n):null,x=Vt(q(C)?zt:C.bridge,y(l),y(c));q(C)||(l=d(f(null),C.props,l),c=d(f(null),C.methods,c),a=C.wire||a?d(f(null),C.wire,a):void 0,p=d(f(null),C.track,p),b=b||C.connectedCallback,w=w||C.disconnectedCallback,$=$||C.renderedCallback,T=T||C.errorCallback,E=E||C.render,r=r||C.template),l=d(f(null),Pr,l),_(s)||h(g,qo(s)),_(r)&&(r=lo);const R={ctor:e,name:o,wire:a,track:p,props:l,methods:c,bridge:x,template:r,connectedCallback:b,disconnectedCallback:w,renderedCallback:$,errorCallback:T,render:E};return m(e.prototype),R}function Ar(e){if(!W(e))return!1;if(e.prototype instanceof Xo)return!0;let t=e;do{if(Ie(t)){const e=Ne(t);if(e===t)return!0;t=e}if(t===Xo)return!0}while(!q(t)&&(t=v(t)));return!1}function Or(e,t){let n=xr.get(e);if(_(n)){if(!Ar(e))throw new TypeError(`${e} is not a valid component, or does not extends LightningElement from "lwc". You probably forgot to add the extend clause on the class declaration.`);let o=function(e){return Ho.get(e)}(e);_(o)&&(o={template:void 0,name:e.name}),n=Sr(e,o,t||e.name),xr.set(e,n)}return n}function Mr(e,t){T(e,t.bridge.prototype)}const Pr=P.call(y(ze),(e,t)=>{const n=Ee(t);return e[t]={config:3,type:"any",attr:n},e},f(null)),{appendChild:Lr,insertBefore:Hr,removeChild:Ir,replaceChild:Nr}=Node.prototype,jr=g(Node.prototype,"parentNode").get,Dr=b.call(Node.prototype,"parentElement")?g(Node.prototype,"parentElement").get:g(HTMLElement.prototype,"parentElement").get;var Fr;!function(e){e[e.created=0]="created",e[e.connected=1]="connected",e[e.disconnected=2]="disconnected"}(Fr||(Fr={}));let Br=0;function _r(e,t,n=[]){return t.apply(e,n)}function qr(e,t,n){e[t]=n}function Vr(e,t){return e[t]}function zr(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),Gr(e)}function Wr(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),Xr(e),Gr(e)}function Kr(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{state:t}=e;if(t!==Fr.disconnected){const{oar:t,tro:n}=e;n.reset();for(const e in t)t[e].reset();!function(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isTrue(e.state!==Fr.disconnected,`${e} must be inserted.`);z(e.isDirty)&&(e.isDirty=!0);e.state=Fr.disconnected;const{disconnected:t}=Vn;t&&Wn(e,t);const{disconnectedCallback:n}=e.def;_(n)||(ko("disconnectedCallback",e),Po(e,n),Co("disconnectedCallback",e))}(e),Zr(e),function(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{aChildren:t}=e;!function e(t){for(let n=0,o=t.length;n<o;n+=1){const o=t[n];q(o)||!E(o.children)||_(o.elm)||(_(o.ctor)?e(o.children):Kr(ii(o.elm)))}}(t)}(e)}}function Ur(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),Kr(e)}function Yr(e,t,n){u.invariant(e instanceof HTMLElement,`VM creation requires a DOM element instead of ${e}.`);const o=Or(t),{isRoot:r,mode:i,owner:a}=n;Br+=1;const s={idx:Br,state:Fr.created,isScheduled:!1,isDirty:!0,isRoot:V(r),mode:i,def:o,owner:a,elm:e,data:Oe,context:f(null),cmpProps:f(null),cmpTrack:f(null),cmpSlots:je?f(null):void 0,callHook:_r,setHook:qr,getHook:Vr,children:Me,aChildren:Me,velements:Me,cmpTemplate:void 0,component:void 0,cmpRoot:void 0,tro:void 0,oar:void 0,toString:()=>`[object:vm ${o.name} (${s.idx})]`};Io(s,t),function(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{def:{wire:t}}=e;if(t){const{wiring:t}=Vn;t&&Wn(e,t)}}(s)}function Gr(e){if(u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),u.isTrue(e.elm instanceof HTMLElement,`rehydration can only happen after ${e} was patched the first time.`),V(e.isDirty)){!function(e,t){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{cmpRoot:n,children:o}=e;if(e.children=t,(t.length>0||o.length>0)&&o!==t){const r=qn(t)?pn:mn;li(e,e,()=>{ko("patch",e)},()=>{r(n,o,t)},()=>{Co("patch",e)})}e.state===Fr.connected&&function(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{rendered:t}=Vn;t&&Wn(e,t);const{renderedCallback:n}=e.def;_(n)||(ko("renderedCallback",e),Po(e,n),Co("renderedCallback",e))}(e)}(e,jo(e))}}let Jr=[];function Qr(){xo(vo.REHYDRATE),u.invariant(Jr.length,`If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${Jr}.`);const e=Jr.sort((e,t)=>e.idx-t.idx);Jr=[];for(let t=0,n=e.length;t<n;t+=1){const o=e[t];try{Gr(o)}catch(o){throw t+1<n&&(0===Jr.length&&He(Qr),N.apply(Jr,H.call(e,t+1))),Ro(vo.REHYDRATE),o}}Ro(vo.REHYDRATE)}function Xr(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{state:t}=e;if(t===Fr.connected)return;e.state=Fr.connected;const{connected:n}=Vn;n&&Wn(e,n);const{connectedCallback:o}=e.def;_(o)||(ko("connectedCallback",e),Po(e,o),Co("connectedCallback",e))}function Zr(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{velements:t}=e;for(let e=t.length-1;e>=0;e-=1){const n=t[e].elm;if(!_(n)){Kr(ii(n))}}}function ei(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),e.children=Me,zo.call(e.cmpRoot,""),Zr(e)}function ti(e){u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`);const{elm:t}=e;return function(e){let t,n=e;for(;!q(n);){if(t=ni(n,Pe),!_(t)&&!_(t.def.errorCallback))return t;n=ri(n)}}(t)}const{getHiddenField:ni}=ee;function oi(e){const t=[];let n=e;do{if(!_(ni(n,Pe))){const e=se.call(n),o=n.getAttribute("is");M.call(t,`<${B.call(e)}${o?' is="${is}':""}>`)}n=ri(n)}while(!q(n));return t.reverse().join("\n\t")}function ri(e){const t=Dr.call(e);return q(t)?function(e){u.isTrue(q(Dr.call(e)),`getHostElement should only be called if the parent element of ${e} is null`);const t=jr.call(e);return t instanceof ShadowRoot?Vo.call(t):null}(e):t}function ii(e){{const t=ni(e,Pe);u.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`)}return ni(e,Pe)}function ai(e){{const t=ni(e,Pe);u.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`)}return ni(e,Pe)}function si(e){{const t=ni(e,Pe);u.isTrue(t&&"cmpRoot"in t,`${t} is not a vm.`)}return ni(e,Pe)}function li(e,t,n,o,r){let i;u.isTrue(e&&"cmpRoot"in e,`${e} is not a vm.`),n();try{o()}catch(e){i=Object(e)}finally{if(r(),!_(i)){i.wcStack=i.wcStack||oi(e.elm);const n=q(t)?void 0:ti(t);if(_(n))throw i;ei(e),ko("errorCallback",n),Po(n,n.def.errorCallback,[i,i.wcStack]),Co("errorCallback",n)}}}const{createFieldName:ci,getHiddenField:ui,setHiddenField:di}=ee,fi=ci("connecting","engine"),hi=ci("disconnecting","engine");function pi(e,t){u.isTrue(e,"callNodeSlot() should not be called for a non-object");const n=ui(e,t);return _(n)||n(),e}d(Node.prototype,{appendChild(e){return pi(Lr.call(this,e),fi)},insertBefore(e,t){return pi(Hr.call(this,e,t),fi)},removeChild(e){return pi(Ir.call(this,e),hi)},replaceChild(e,t){const n=Nr.call(this,e,t);return pi(n,hi),pi(e,fi),n}}),t.LightningElement=Xo,t.api=br,t.buildCustomElementConstructor=function(e,t){var n;const{props:o,bridge:r}=Or(e),i={mode:"open",isRoot:!0,owner:null};if(K(t)&&!q(t)){const{mode:e}=t;"closed"===e&&(i.mode=e)}return(n=class extends r{constructor(){super(),Yr(this,e,i),Rn(this,Oe)}connectedCallback(){Wr(ii(this))}disconnectedCallback(){Ur(ii(this))}attributeChangedCallback(e,t,n){if(t===n)return;const r=function(e){return _(be[e])&&(be[e]=D.call(e,$e,e=>e[1].toUpperCase())),be[e]}(e);_(o[r])||function(e,t){return e!==Ce||t!==ke}(this,e)&&(this[r]=n)}}).observedAttributes=O.call(y(o),e=>o[e].attr),n},t.createElement=function(e,t){if(!K(t)||q(t))throw new TypeError(`"createElement" function expects an object as second parameter but received "${G(t)}".`);let n=t.is;if(!W(n))throw new TypeError('"createElement" function expects a "is" option with a valid component constructor.');const o="closed"!==t.mode?"open":"closed",r=document.createElement(e);if(!_(ui(r,Pe)))return r;Ie(n)&&(n=Ne(n));const i=Or(n);return Mr(r,i),Rn(r,Oe),Yr(r,n,{mode:o,isRoot:!0,owner:null}),di(r,fi,()=>{const e=ii(r);xo(vo.HYDRATE,e),e.state===Fr.connected&&Ur(e),Wr(e),Ro(vo.HYDRATE,e)}),di(r,hi,()=>{Ur(ii(r))}),r},t.decorate=Er,t.getComponentConstructor=function(e){let t=null;if(e instanceof HTMLElement){const n=Rr(e,Pe);_(n)||(t=n.def.ctor)}return t},t.getComponentDef=Or,t.isComponentConstructor=Ar,t.isNodeFromTemplate=function(e){return!z(e instanceof Node)&&(!(e instanceof ShadowRoot)&&((!je||!_(e.$shadowResolver$))&&e.getRootNode()instanceof ShadowRoot))},t.readonly=function(e){return 1!==arguments.length&&u.fail("@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value."),Nt.getReadOnlyProxy(e)},t.register=function(e){u.isTrue(K(e),`Invalid service declaration, ${e}: service must be an object`);for(let t=0;t<zn.length;++t){const n=zn[t];if(n in e){let t=Vn[n];_(t)&&(Vn[n]=t=[]),M.call(t,e[n])}}},t.registerComponent=function(e,{name:t,tmpl:n}){return Ho.set(e,{name:t,template:n}),e},t.registerDecorators=function(e,t){const n=f(null),o=function(e,t){if(_(t)||0===y(t).length)return Oe;return y(t).reduce((e,n)=>{const o=Ee(n);return e[n]=d({config:0,type:"any",attr:o},t[n]),e},f(null))}(0,t.publicProps),r=function(e,t){if(_(t)||0===t.length)return Oe;return t.reduce((t,n)=>(u.isTrue(W(e.prototype[n]),`Component "${e.name}" should have a method \`${n}\` instead of ${e.prototype[n]}.`),t[n]=e.prototype[n],t),f(null))}(e,t.publicMethods),i=function(e,t){if(_(t)||0===y(t).length)return;return d(f(null),t)}(0,t.wire),a=function(e,t){if(_(t)||0===y(t).length)return Oe;return d(f(null),t)}(0,t.track),s=t.fields;kr.set(e,{props:o,methods:r,wire:i,track:a,fields:s});for(const e in o)n[e]=br;if(i)for(const e in i){const t=i[e];t.method||(n[e]=nr(t.adapter,t.params))}if(a)for(const e in a)n[e]=Zo;return Er(e,n),e},t.registerTemplate=function(e){return so.add(e),e},t.sanitizeAttribute=function(e,t,n,o){return o},t.setFeatureFlag=yr,t.setFeatureFlagForTest=function(e,t){if(mr(vr[e]))throw new Error(`Feature flag "${e}" is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.`);return yr(e,t)},t.track=Zo,t.unwrap=function(e){const t=Nt.unwrapProxy(e);return t!==e?t:e},t.wire=nr}).call(this,n(2))}]]);